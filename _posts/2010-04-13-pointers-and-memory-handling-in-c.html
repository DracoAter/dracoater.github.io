---
layout: post
title: Pointers and Memory Handling In C++
date: '2010-04-13T21:58:00.002+03:00'
author: Juri Timo≈°in
tags:
- C++
modified_time: '2010-07-09T14:12:26.040+03:00'
blogger_id: tag:blogger.com,1999:blog-360329120074358364.post-8523906795025417242
blogger_orig_url: http://dracoater.blogspot.com/2010/03/pointers-and-memory-handling-in-c.html
---

<p>Handling memory resources doesn't need any special knowledge in C++, the memory is freed as soon as the variable is out of scope. Unless you are dealing with pointers. Memory that is addressed by pointer is not freed automatically, even if you are out the scope already. It should be done manually, using <i>delete</i> or some provided special function (If it's some library).</p>
<p>Let's take the following function as an example.</p>
<pre><code class="cpp">void use_file( const char* fn ){
  FILE* f = fopen( fn, "w" );
  //using f;
  fclose( f );
}</code></pre>
<p>At first sight nothing seems to be wrong here. The memory allocated by <i>fopen</i> is freed at the end of the function with <i>fclose</i>. But what if some exception occurs between those two? Yes, the memory will not be freed. The first attempt to fix this is to add exception handling.</p>
<pre><code class="cpp">void use_file( const char* fn ){
  FILE* f = fopen( fn, "w" );
  try {
    //using f;
  }
  catch(...){
    fclose( f );
    throw;
  }
  fclose( f );
}</code></pre>
<p>The problem of this solution is that it is too diffusive. Anybody wants to write everywhere try-catch blocks, just to make sure the memory is freed? I am too lazy to do that. There should be a more elegant solution. We can define a class File_ptr, that will behave just like FILE*, but will free resources automatically.</p>
<pre><code class="cpp">class File_ptr{
  FILE* fp;
public:

  //Constructor that creates File_ptr from FILE*
  File_ptr( FILE* pp ){ fp = pp; }
  
  //Destructor, that closes the file and frees memory
  ~File_ptr(){ if (fp) fclose( fp ) };
  
  //Type conversion operator. It is called every time an object 
  //of File_ptr type needs to be converted to FILE*;
  operator FILE* (){ return fp; }
}</code></pre>
<p>This is a minimum amount of functions that needed for this wrapper class to work. The <i>use_file</i> function then will look like that.</p>
<pre><code class="cpp">void use_file( const char* fn ){
  File_ptr f = fopen( fn, "w" );
  //using f;
  //file will be closed automatically as soon as f is out of scope
}</code></pre>
<p>But actually it is not all yet. You will also need to define a copy constructor and an assign operator in <i>File_ptr</i>. <a href="http://pages.cs.wisc.edu/~hasti/cs368/CppTutorial/NOTES/CLASSES-PTRS.html" class="external" >Here</a> is the good explanation, why.</p>